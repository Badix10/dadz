# Plan d'impl√©mentation - Gestion des Adresses

## üìã Vue d'ensemble

Impl√©mentation d'un syst√®me complet de gestion des adresses pour les clients, avec:
- CRUD complet sur les adresses (max 3 par utilisateur)
- G√©olocalisation gratuite avec `expo-location`
- Formulaire de saisie manuelle avec validation
- √âtat global avec Zustand
- Tests unitaires et d'int√©gration
- Support i18n (en, fr, ar)
- Support du dark mode

---

## üéØ Objectifs et contraintes

### Contraintes m√©tier
1. **Maximum 3 adresses par utilisateur**
2. **Une seule adresse peut √™tre marqu√©e comme "par d√©faut"**
3. **Types d'adresse**: home, work, other
4. **Si suppression de l'adresse par d√©faut**: la premi√®re adresse restante devient par d√©faut

### Contraintes techniques
- **Co√ªt de d√©veloppement: 0‚Ç¨** (pas de Google Places API)
- **Architecture en couches**: Services ‚Üí Store ‚Üí Hooks ‚Üí Components ‚Üí Screens
- **Tests obligatoires** pour assurer la non-r√©gression
- **S√©paration claire**: requ√™tes Supabase isol√©es dans des services

---

## üèóÔ∏è Architecture

```
lib/
  services/
    addressService.ts       # Toutes les requ√™tes Supabase pour addresses
    locationService.ts      # G√©olocalisation avec expo-location

  store/
    addressStore.ts         # Store Zustand pour √©tat global des adresses

  validations/
    addressSchema.ts        # Sch√©mas Zod pour validation

  utils/
    addressHelpers.ts       # Fonctions helpers m√©tier

hooks/
  useAddresses.ts           # Hook qui consomme le store Zustand
  useLocation.ts            # Hook pour g√©olocalisation

components/
  addresses/
    AddressCard.tsx         # Carte affichant une adresse
    AddressForm.tsx         # Formulaire de cr√©ation/√©dition
    AddressModal.tsx        # Modale conteneur
    AddressEmptyState.tsx   # √âtat vide
    LocationButton.tsx      # Bouton "Ma position"

app/
  addresses/
    index.tsx               # Screen principal - liste des adresses

i18n/
  locales/
    en/addresses.json
    fr/addresses.json
    ar/addresses.json

__tests__/
  services/
    addressService.test.ts
    locationService.test.ts
  store/
    addressStore.test.ts
  hooks/
    useAddresses.test.ts
  components/
    AddressCard.test.tsx
    AddressForm.test.tsx
```

---

## üì¶ D√©pendances install√©es

### Production
```json
{
  "zustand": "^4.x",           // State management global
  "expo-location": "^17.x",     // G√©olocalisation gratuite
  "zod": "^3.x",                // Validation (d√©j√† install√©)
  "react-hook-form": "^7.x"     // Formulaires (d√©j√† install√©)
}
```

### D√©veloppement
```json
{
  "@testing-library/react-native": "^13.x",
  "@testing-library/react-hooks": "^8.x",
  "jest": "^29.x"               // D√©j√† install√© avec React Native
}
```

---

## üîÑ Flux de donn√©es

```
User Action
    ‚Üì
Component (AddressCard, AddressForm)
    ‚Üì
Hook (useAddresses)
    ‚Üì
Store Zustand (addressStore)
    ‚Üì
Service (addressService)
    ‚Üì
Supabase
```

### Store Zustand - Structure

```typescript
interface AddressState {
  // √âtat
  addresses: Address[];
  selectedAddress: Address | null;
  loading: boolean;
  error: string | null;

  // Actions
  fetchAddresses: (userId: string) => Promise<void>;
  createAddress: (address: AddressInsert) => Promise<void>;
  updateAddress: (id: string, updates: AddressUpdate) => Promise<void>;
  deleteAddress: (id: string) => Promise<void>;
  setAsDefault: (id: string) => Promise<void>;
  selectAddress: (address: Address | null) => void;

  // Getters
  getDefaultAddress: () => Address | null;
  canAddAddress: () => boolean;
}
```

---

## üóÉÔ∏è Services

### addressService.ts

```typescript
export const addressService = {
  // R√©cup√©rer toutes les adresses d'un utilisateur
  getAddresses: async (profileId: string): Promise<Address[]> => {
    const { data, error } = await supabase
      .from('addresses')
      .select('*')
      .eq('profile_id', profileId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data || [];
  },

  // Cr√©er une nouvelle adresse
  createAddress: async (address: TablesInsert<'addresses'>): Promise<Address> => {
    const { data, error } = await supabase
      .from('addresses')
      .insert(address)
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  // Mettre √† jour une adresse
  updateAddress: async (id: string, updates: TablesUpdate<'addresses'>): Promise<Address> => {
    const { data, error } = await supabase
      .from('addresses')
      .update(updates)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  // Supprimer une adresse
  deleteAddress: async (id: string): Promise<void> => {
    const { error } = await supabase
      .from('addresses')
      .delete()
      .eq('id', id);

    if (error) throw error;
  },

  // Retirer le flag "default" de toutes les adresses sauf une
  removeDefaultFromOthers: async (profileId: string, exceptId?: string): Promise<void> => {
    let query = supabase
      .from('addresses')
      .update({ is_default: false })
      .eq('profile_id', profileId);

    if (exceptId) {
      query = query.neq('id', exceptId);
    }

    const { error } = await query;
    if (error) throw error;
  },

  // Compter les adresses d'un utilisateur
  countAddresses: async (profileId: string): Promise<number> => {
    const { count, error } = await supabase
      .from('addresses')
      .select('*', { count: 'exact', head: true })
      .eq('profile_id', profileId);

    if (error) throw error;
    return count || 0;
  }
};
```

### locationService.ts

```typescript
import * as Location from 'expo-location';

export const locationService = {
  // Demander la permission de localisation
  requestPermission: async (): Promise<boolean> => {
    const { status } = await Location.requestForegroundPermissionsAsync();
    return status === 'granted';
  },

  // R√©cup√©rer l'adresse actuelle via g√©olocalisation
  getCurrentAddress: async (): Promise<ParsedAddress> => {
    // V√©rifier permission
    const hasPermission = await locationService.requestPermission();
    if (!hasPermission) {
      throw new Error('Permission de localisation refus√©e');
    }

    // Obtenir coordonn√©es
    const location = await Location.getCurrentPositionAsync({
      accuracy: Location.Accuracy.High
    });

    // Reverse geocoding
    const addresses = await Location.reverseGeocodeAsync({
      latitude: location.coords.latitude,
      longitude: location.coords.longitude,
    });

    if (!addresses || addresses.length === 0) {
      throw new Error('Impossible de r√©cup√©rer l\'adresse');
    }

    // Parser le r√©sultat
    const addr = addresses[0];
    return {
      street: `${addr.streetNumber || ''} ${addr.street || ''}`.trim(),
      city: addr.city || '',
      postal_code: addr.postalCode || '',
      country: addr.country || 'France',
    };
  }
};

interface ParsedAddress {
  street: string;
  city: string;
  postal_code: string;
  country: string;
}
```

---

## ‚úÖ Validation Zod

### addressSchema.ts

```typescript
import { z } from 'zod';

export const addressSchema = z.object({
  street: z
    .string()
    .min(1, 'validation.streetRequired')
    .min(5, 'validation.streetMin'),

  city: z
    .string()
    .min(1, 'validation.cityRequired')
    .min(2, 'validation.cityMin'),

  postal_code: z
    .string()
    .min(1, 'validation.postalCodeRequired')
    .regex(/^[0-9]{4,10}$/, 'validation.postalCodeInvalid'),

  country: z
    .string()
    .min(1, 'validation.countryRequired')
    .min(2, 'validation.countryMin'),

  address_type: z.enum(['home', 'work', 'other'], {
    errorMap: () => ({ message: 'validation.addressTypeRequired' })
  }),

  is_default: z.boolean().optional().default(false),
});

export type AddressFormData = z.infer<typeof addressSchema>;
```

---

## üåê Traductions (i18n)

### Structure des fichiers

#### fr/addresses.json

```json
{
  "title": "Mes adresses",
  "subtitle": "G√©rez vos adresses de livraison (max 3)",

  "emptyState": {
    "title": "Aucune adresse enregistr√©e",
    "message": "Ajoutez votre premi√®re adresse de livraison pour commander",
    "action": "Ajouter une adresse"
  },

  "addButton": "Ajouter une adresse",
  "limitBadge": "{{count}}/3 adresses",
  "maxReached": "Limite atteinte",
  "maxReachedMessage": "Vous avez atteint la limite de 3 adresses. Supprimez-en une pour en ajouter une nouvelle.",

  "addressTypes": {
    "home": "Domicile",
    "work": "Travail",
    "other": "Autre"
  },

  "form": {
    "title": {
      "create": "Nouvelle adresse",
      "edit": "Modifier l'adresse"
    },

    "manualEntry": "Saisie manuelle",
    "useLocation": "Utiliser ma position",

    "fields": {
      "street": {
        "label": "Rue",
        "placeholder": "Ex: 123 Rue de la Paix"
      },
      "city": {
        "label": "Ville",
        "placeholder": "Ex: Paris"
      },
      "postalCode": {
        "label": "Code postal",
        "placeholder": "Ex: 75001"
      },
      "country": {
        "label": "Pays",
        "placeholder": "Ex: France"
      },
      "addressType": {
        "label": "Type d'adresse"
      },
      "isDefault": {
        "label": "Adresse par d√©faut",
        "helper": "Sera utilis√©e par d√©faut pour vos commandes"
      }
    },

    "actions": {
      "save": "Enregistrer",
      "cancel": "Annuler",
      "saving": "Enregistrement..."
    }
  },

  "validation": {
    "streetRequired": "La rue est requise",
    "streetMin": "La rue doit contenir au moins 5 caract√®res",
    "cityRequired": "La ville est requise",
    "cityMin": "La ville doit contenir au moins 2 caract√®res",
    "postalCodeRequired": "Le code postal est requis",
    "postalCodeInvalid": "Code postal invalide (4-10 chiffres)",
    "countryRequired": "Le pays est requis",
    "countryMin": "Le pays doit contenir au moins 2 caract√®res",
    "addressTypeRequired": "Le type d'adresse est requis"
  },

  "actions": {
    "edit": "Modifier",
    "delete": "Supprimer",
    "setAsDefault": "D√©finir par d√©faut",
    "viewDetails": "Voir d√©tails"
  },

  "deleteConfirm": {
    "title": "Supprimer l'adresse ?",
    "message": "Cette action est irr√©versible.",
    "confirm": "Supprimer",
    "cancel": "Annuler"
  },

  "messages": {
    "createSuccess": "Adresse ajout√©e avec succ√®s",
    "updateSuccess": "Adresse mise √† jour",
    "deleteSuccess": "Adresse supprim√©e",
    "setDefaultSuccess": "Adresse par d√©faut mise √† jour",
    "createError": "Impossible d'ajouter l'adresse",
    "updateError": "Impossible de mettre √† jour l'adresse",
    "deleteError": "Impossible de supprimer l'adresse",
    "locationPermissionDenied": "Permission de localisation refus√©e",
    "locationError": "Impossible de r√©cup√©rer votre position",
    "maxAddressesError": "Vous avez atteint la limite de 3 adresses"
  },

  "labels": {
    "default": "Par d√©faut",
    "notDefault": "Non par d√©faut"
  }
}
```

---

## üß™ Strat√©gie de tests

### Tests √† impl√©menter

#### 1. Services Tests

##### addressService.test.ts
- ‚úÖ R√©cup√©ration des adresses
- ‚úÖ Cr√©ation d'une adresse
- ‚úÖ Mise √† jour d'une adresse
- ‚úÖ Suppression d'une adresse
- ‚úÖ Retirer le flag default des autres adresses
- ‚úÖ Compter les adresses
- ‚úÖ Gestion des erreurs Supabase

##### locationService.test.ts
- ‚úÖ Demande de permission
- ‚úÖ R√©cup√©ration de l'adresse actuelle
- ‚úÖ Permission refus√©e
- ‚úÖ Erreur de g√©olocalisation
- ‚úÖ Parsing de l'adresse

#### 2. Store Tests

##### addressStore.test.ts
- ‚úÖ √âtat initial
- ‚úÖ fetchAddresses met √† jour l'√©tat
- ‚úÖ createAddress ajoute une adresse
- ‚úÖ updateAddress met √† jour l'adresse
- ‚úÖ deleteAddress retire l'adresse
- ‚úÖ setAsDefault change l'adresse par d√©faut
- ‚úÖ canAddAddress retourne false si 3 adresses
- ‚úÖ getDefaultAddress retourne la bonne adresse

#### 3. Hooks Tests

##### useAddresses.test.ts
- ‚úÖ R√©cup√©ration initiale des adresses
- ‚úÖ Cr√©ation d'une adresse
- ‚úÖ Limite de 3 adresses respect√©e
- ‚úÖ Mise √† jour de l'adresse par d√©faut
- ‚úÖ Suppression avec gestion du default

#### 4. Components Tests

##### AddressCard.test.tsx
- ‚úÖ Affichage des informations
- ‚úÖ Badge "Par d√©faut" visible si is_default
- ‚úÖ Actions (modifier, supprimer) appellent les callbacks
- ‚úÖ Dark mode support

##### AddressForm.test.tsx
- ‚úÖ Validation des champs
- ‚úÖ Soumission du formulaire
- ‚úÖ Pr√©-remplissage en mode √©dition
- ‚úÖ Bouton "Ma position" appelle locationService
- ‚úÖ Messages d'erreur affich√©s

---

## üìù √âtapes d'impl√©mentation

### Phase 1: Fondations (Services + Validation)
1. ‚úÖ Cr√©er `lib/services/addressService.ts` avec toutes les requ√™tes Supabase
2. ‚úÖ Cr√©er `lib/services/locationService.ts` avec expo-location
3. ‚úÖ Cr√©er `lib/validations/addressSchema.ts` avec Zod
4. ‚úÖ Cr√©er `lib/utils/addressHelpers.ts` pour fonctions utilitaires

### Phase 2: √âtat global (Store Zustand)
5. ‚úÖ Cr√©er `lib/store/addressStore.ts` avec Zustand
6. ‚úÖ Impl√©menter toutes les actions (fetch, create, update, delete, setAsDefault)
7. ‚úÖ Impl√©menter les getters (getDefaultAddress, canAddAddress)

### Phase 3: Traductions
8. ‚úÖ Cr√©er `i18n/locales/en/addresses.json`
9. ‚úÖ Cr√©er `i18n/locales/fr/addresses.json`
10. ‚úÖ Cr√©er `i18n/locales/ar/addresses.json`

### Phase 4: Hooks
11. ‚úÖ Cr√©er `hooks/useAddresses.ts` qui consomme le store
12. ‚úÖ Cr√©er `hooks/useLocation.ts` pour la g√©olocalisation

### Phase 5: Composants UI
13. ‚úÖ Cr√©er `components/addresses/AddressCard.tsx`
14. ‚úÖ Cr√©er `components/addresses/AddressEmptyState.tsx`
15. ‚úÖ Cr√©er `components/addresses/LocationButton.tsx`
16. ‚úÖ Cr√©er `components/addresses/AddressForm.tsx`
17. ‚úÖ Cr√©er `components/addresses/AddressModal.tsx`

### Phase 6: Screen principal
18. ‚úÖ Cr√©er `app/addresses/index.tsx`
19. ‚úÖ Impl√©menter la liste des adresses
20. ‚úÖ Impl√©menter la cr√©ation via modale
21. ‚úÖ Impl√©menter l'√©dition via modale
22. ‚úÖ Impl√©menter la suppression avec confirmation
23. ‚úÖ Impl√©menter le toggle "par d√©faut"

### Phase 7: Int√©gration
24. ‚úÖ Connecter le bouton "Adresses" dans `app/(tabs)/profile.tsx`
25. ‚úÖ Tester le flux complet

### Phase 8: Tests (apr√®s impl√©mentation)
26. ‚úÖ √âcrire les tests pour addressService
27. ‚úÖ √âcrire les tests pour locationService
28. ‚úÖ √âcrire les tests pour addressStore
29. ‚úÖ √âcrire les tests pour useAddresses
30. ‚úÖ √âcrire les tests pour AddressCard
31. ‚úÖ √âcrire les tests pour AddressForm
32. ‚úÖ Lancer la suite de tests compl√®te

---

## üé® UX/UI Guidelines

### Parcours utilisateur

#### Cr√©ation premi√®re adresse
1. User arrive sur `/addresses` ‚Üí Empty state
2. Tap "Ajouter une adresse" ‚Üí Modale s'ouvre
3. Deux options:
   - Formulaire manuel (champs visibles)
   - Bouton "Utiliser ma position" (GPS icon)
4. Submit ‚Üí Modale se ferme ‚Üí Adresse appara√Æt
5. Toast: "Adresse ajout√©e avec succ√®s ‚úì"

#### Ajout 2√®me/3√®me adresse
1. Badge "1/3" ou "2/3" visible
2. Bouton "Ajouter" actif
3. √Ä 3 adresses ‚Üí Bouton d√©sactiv√© + message

#### Modification
1. Tap sur carte ‚Üí Modale en mode √©dition
2. Formulaire pr√©-rempli
3. Submit ‚Üí Update optimiste ‚Üí Toast

#### Suppression
1. Swipe left ou bouton "Supprimer"
2. Alert de confirmation
3. Confirm ‚Üí Animation de suppression
4. Si derni√®re ‚Üí Empty state

#### D√©finir par d√©faut
1. Tap sur toggle/√©toile
2. Animation
3. Autres cartes perdent le badge "Par d√©faut"
4. R√©organisation: par d√©faut en premier

### Design patterns
- Loading states (skeletons)
- Optimistic updates
- Error boundaries
- Pull-to-refresh
- Swipe actions
- Animations fluides
- Dark mode natif

---

## üîê Logique m√©tier

### R√®gles strictes

```typescript
// 1. Limite de 3 adresses
const canAddAddress = (count: number): boolean => count < 3;

// 2. Une seule par d√©faut
const setAsDefault = async (id: string, profileId: string) => {
  // Retirer default des autres
  await addressService.removeDefaultFromOthers(profileId, id);
  // Mettre √† jour celle-ci
  await addressService.updateAddress(id, { is_default: true });
};

// 3. Gestion apr√®s suppression
const handleDelete = async (address: Address, addresses: Address[]) => {
  await addressService.deleteAddress(address.id);

  // Si c'√©tait la par d√©faut et qu'il reste des adresses
  if (address.is_default && addresses.length > 1) {
    const remaining = addresses.filter(a => a.id !== address.id);
    await setAsDefault(remaining[0].id, address.profile_id);
  }
};
```

---

## üìä Performance

### Optimisations
- **Zustand** pour √©viter re-renders inutiles
- **Optimistic updates** pour UX instantan√©e
- **Debounce** sur les inputs si autocomplete futur
- **Memoization** des composants lourds
- **React.memo** sur AddressCard

### Monitoring
- Temps de chargement des adresses
- Temps de r√©ponse Supabase
- Taux d'erreur de g√©olocalisation

---

## üöÄ D√©ploiement et CI/CD

### Checklist avant merge
- [ ] Tous les tests passent
- [ ] Coverage > 80%
- [ ] Traductions compl√®tes (en, fr, ar)
- [ ] Dark mode fonctionnel
- [ ] Test√© sur iOS et Android
- [ ] RLS Supabase v√©rifi√©
- [ ] Pas de console.log/error

---

## üìö Documentation technique

### Types TypeScript

```typescript
// Tir√© de database.types.ts
type Address = Tables<'addresses'>;
type AddressInsert = TablesInsert<'addresses'>;
type AddressUpdate = TablesUpdate<'addresses'>;

// Type du store
interface AddressState {
  addresses: Address[];
  selectedAddress: Address | null;
  loading: boolean;
  error: string | null;
  fetchAddresses: (userId: string) => Promise<void>;
  createAddress: (address: AddressInsert) => Promise<void>;
  updateAddress: (id: string, updates: AddressUpdate) => Promise<void>;
  deleteAddress: (id: string) => Promise<void>;
  setAsDefault: (id: string) => Promise<void>;
  selectAddress: (address: Address | null) => void;
  getDefaultAddress: () => Address | null;
  canAddAddress: () => boolean;
}
```

---

## üéØ R√©sum√© des d√©cisions

| D√©cision | Choix | Raison |
|----------|-------|--------|
| State management | Zustand | √âtat global, simple, performant |
| G√©olocalisation | expo-location | Gratuit, int√©gr√© Expo |
| Validation | Zod | Type-safe, messages i18n |
| Tests | Jest + Testing Library | Standard React Native |
| Architecture | Layered (Services ‚Üí Store ‚Üí Hooks ‚Üí Components) | S√©paration des responsabilit√©s |
| Autocomplete | ‚ùå Non impl√©ment√© | Co√ªt Google Places |

---

## üìÖ Estimation

| Phase | T√¢ches | Temps estim√© |
|-------|--------|--------------|
| Phase 1-2 | Services + Store | 2h |
| Phase 3 | Traductions | 30min |
| Phase 4 | Hooks | 1h |
| Phase 5 | Composants | 3h |
| Phase 6 | Screen | 2h |
| Phase 7 | Int√©gration | 30min |
| Phase 8 | Tests | 3h |
| **TOTAL** | | **~12h** |

---

## ‚úÖ Validation du plan

**Plan valid√© le:** 2025-10-22

**Valid√© par:** √âquipe de d√©veloppement

**Statut:** Pr√™t pour impl√©mentation

---

## üîÑ Prochaines √©tapes

1. ‚úÖ Installer les d√©pendances (zustand, expo-location, testing libs)
2. ‚úÖ Sauvegarder ce plan dans `./plan/`
3. üöÄ Commencer Phase 1: Cr√©er les services
